"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCommandInDirs = void 0;
const chalk_1 = require("chalk");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const path_1 = require("path");
const logger_1 = require("./logger");
async function runCommandInDirs(command, directories, options) {
    if (options.parallel) {
        return Promise.all(directories.map((directory) => runCommandInDir(command, directory, options))).then((exitCodes) => { var _a; return (_a = exitCodes.sort().pop()) !== null && _a !== void 0 ? _a : 0; });
    }
    let maxExitCode = 0;
    for (const directory of directories) {
        maxExitCode = Math.max(maxExitCode, await runCommandInDir(command, directory, options));
    }
    return maxExitCode;
}
exports.runCommandInDirs = runCommandInDirs;
function runCommandInDir(command, directory, options) {
    const { isYarn, silent, args } = options;
    const isInstallCommand = command === 'install';
    const absoluteDirectory = path_1.join(process.cwd(), directory);
    if (!fs_1.existsSync(absoluteDirectory)) {
        logger_1.default.error(`Directory '${directory}' not found!`, directory);
        return;
    }
    const packageFilePath = path_1.join(absoluteDirectory, 'package.json');
    if (!fs_1.existsSync(packageFilePath)) {
        logger_1.default.error(`File '${directory}/package.json' not found!`, directory);
        return;
    }
    const packageFile = JSON.parse(fs_1.readFileSync(packageFilePath).toString());
    if (!isInstallCommand &&
        (!packageFile.scripts || !packageFile.scripts[command])) {
        logger_1.default.error(`Command '${command}' not found in '${directory}/package.json'!`, directory);
        return;
    }
    const fullCmd = {
        command: isYarn ? 'yarn' : 'npm',
        args: `${isInstallCommand ? '' : 'run'} ${command} ${args}`
            .split(/ +/)
            .filter(Boolean),
    };
    logger_1.default.log(`${chalk_1.yellow.bold(fullCmd.command)} ${chalk_1.yellow.bold(fullCmd.args.join(' '))}`, directory);
    return new Promise((resolve) => {
        const child = child_process_1.spawn(fullCmd.command, fullCmd.args, {
            cwd: absoluteDirectory,
        });
        if (!silent) {
            child.stdout.on('data', (chunk) => logger_1.default.log(Buffer.from(chunk).toString(), directory));
            child.stderr.on('data', (chunk) => logger_1.default.error(Buffer.from(chunk).toString(), directory));
        }
        child.on('exit', resolve);
    });
}
//# sourceMappingURL=runner.js.map